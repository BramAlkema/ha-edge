#!/usr/bin/with-contenv bashio
#
# GCP Tunnel Client - connects to Cloud Run chisel server
#
# Features:
# - Setup mode: generates config, shows deployment instructions
# - Exponential backoff on reconnect
# - Graceful shutdown handling
# - Connection monitoring
#

# Exit on undefined variables
set -u

# Configuration
MAX_BACKOFF=300  # 5 minutes max
INITIAL_BACKOFF=5
BACKOFF_MULTIPLIER=2
GENERATED_PASS_FILE="/config/.gcp_tunnel_password"
LOG_FILE="/tmp/gcp_tunnel.log"
MAX_LOG_SIZE=1048576  # 1MB

# State
current_backoff=$INITIAL_BACKOFF
consecutive_failures=0
chisel_pid=""
DEBUG_MODE=false

# Structured logging helper
# Outputs JSON-style structured logs when debug mode enabled
log_structured() {
    local level="$1"
    local component="$2"
    local message="$3"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if [ "$DEBUG_MODE" = true ]; then
        # JSON structured format for debug
        echo "{\"ts\":\"$timestamp\",\"level\":\"$level\",\"component\":\"$component\",\"msg\":\"$message\"}" >> "$LOG_FILE"
    fi

    # Also output via bashio (always)
    case "$level" in
        debug)
            [ "$DEBUG_MODE" = true ] && bashio::log.debug "[$component] $message"
            ;;
        info)
            bashio::log.info "[$component] $message"
            ;;
        warning)
            bashio::log.warning "[$component] $message"
            ;;
        error)
            bashio::log.error "[$component] $message"
            ;;
    esac
}

# Log rotation - keeps log file under MAX_LOG_SIZE
rotate_log() {
    if [ -f "$LOG_FILE" ]; then
        local size
        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo 0)
        if [ "$size" -gt "$MAX_LOG_SIZE" ]; then
            mv "$LOG_FILE" "${LOG_FILE}.1"
            log_structured "info" "system" "Log rotated"
        fi
    fi
}

# Graceful shutdown handler
shutdown() {
    bashio::log.info "Received shutdown signal, stopping tunnel..."
    if [ -n "$chisel_pid" ] && kill -0 "$chisel_pid" 2>/dev/null; then
        kill -TERM "$chisel_pid" 2>/dev/null || true
        wait "$chisel_pid" 2>/dev/null || true
    fi
    # Stop nginx proxy
    nginx -s stop 2>/dev/null || pkill nginx 2>/dev/null || true
    bashio::log.info "Tunnel stopped"
    exit 0
}

# Set up signal handlers
trap shutdown SIGTERM SIGINT SIGHUP

# Validate URL format
validate_url() {
    local url="$1"
    if [[ ! "$url" =~ ^https?:// ]] && [[ ! "$url" =~ ^wss?:// ]]; then
        bashio::log.fatal "Invalid server URL format: $url"
        bashio::log.fatal "URL must start with https:// or wss://"
        exit 1
    fi
}

# Mark that we need a restart after first config
mark_restart_needed() {
    touch "/config/.gcp_tunnel_needs_restart"
}

# Ensure packages are enabled in configuration.yaml
enable_packages() {
    local config_file="/config/configuration.yaml"

    # Check if packages line already exists
    if grep -q "packages:" "$config_file" 2>/dev/null; then
        bashio::log.info "Packages already configured in configuration.yaml"
        return 0
    fi

    bashio::log.info "Adding packages configuration to configuration.yaml..."

    # Check if homeassistant: section exists
    if grep -q "^homeassistant:" "$config_file" 2>/dev/null; then
        # Add packages under existing homeassistant section
        sed -i '/^homeassistant:/a\  packages: !include_dir_named packages' "$config_file"
    else
        # Add new homeassistant section at the top
        sed -i '1i\homeassistant:\n  packages: !include_dir_named packages\n' "$config_file"
    fi

    bashio::log.info "Packages enabled - HA Core will restart automatically"
    mark_restart_needed
}

# Setup tunnel status sensors for HA Dashboard
setup_tunnel_sensors() {
    bashio::log.info "Dashboard: Setting up tunnel status sensors..."

    # Create packages directory if it doesn't exist
    mkdir -p /config/packages

    # Enable packages in configuration.yaml
    enable_packages

    # Write sensor package for tunnel status
    local sensor_file="/config/packages/gcp_tunnel_sensors.yaml"

    cat > "$sensor_file" << 'EOF'
# Auto-generated by GCP Tunnel Client add-on
# Provides sensors for tunnel status monitoring

rest:
  - resource: http://localhost:8099/health
    scan_interval: 30
    sensor:
      - name: "GCP Tunnel Status"
        unique_id: gcp_tunnel_status
        value_template: "{{ value_json.status }}"
        icon: >-
          {% if value_json.status == 'healthy' %}
            mdi:cloud-check
          {% else %}
            mdi:cloud-off-outline
          {% endif %}
        json_attributes:
          - tunnel_connected
          - proxy_running
          - server_url
          - project_id
          - report_state_enabled
          - setup_complete

template:
  - binary_sensor:
      - name: "GCP Tunnel Connected"
        unique_id: gcp_tunnel_connected
        device_class: connectivity
        state: "{{ state_attr('sensor.gcp_tunnel_status', 'tunnel_connected') | default(false) }}"
        icon: mdi:tunnel

      - name: "GCP Tunnel Report State"
        unique_id: gcp_tunnel_report_state
        state: "{{ state_attr('sensor.gcp_tunnel_status', 'report_state_enabled') | default(false) }}"
        icon: mdi:home-assistant
EOF

    bashio::log.info "Dashboard: Sensors configured at $sensor_file"
}

# Setup Google Assistant package configuration
# Uses HA's built-in integration with service account for report_state
setup_google_assistant() {
    local project_id
    project_id=$(bashio::config 'google_project_id')

    # Always setup tunnel sensors (don't require project_id)
    setup_tunnel_sensors

    # Skip Google Assistant if no project ID configured
    if bashio::var.is_empty "$project_id"; then
        bashio::log.info "Google Assistant: No project_id configured, skipping auto-setup"
        return 0
    fi

    bashio::log.info "Google Assistant: Setting up packages configuration..."

    # Create packages directory if it doesn't exist
    mkdir -p /config/packages

    # Check if service account exists (uploaded via webapp)
    local sa_file="/data/service_account.json"
    local has_service_account=false
    if [ -f "$sa_file" ]; then
        # Copy service account to config directory for HA to use
        cp "$sa_file" /config/gcp_tunnel_service_account.json
        chmod 600 /config/gcp_tunnel_service_account.json
        has_service_account=true
        bashio::log.info "Google Assistant: Service account found, enabling report_state"
    fi

    # Get optional PIN for secure devices
    local secure_pin
    secure_pin=$(bashio::config 'google_secure_devices_pin')

    # Write the google_assistant package
    # Uses HA's built-in JWT, token refresh, batching - we just configure it
    local package_file="/config/packages/gcp_tunnel_google_assistant.yaml"

    cat > "$package_file" << EOF
# Auto-generated by GCP Tunnel Client add-on
# Uses Home Assistant's built-in Google Assistant integration
# https://www.home-assistant.io/integrations/google_assistant/

google_assistant:
  project_id: ${project_id}
  expose_by_default: true
  exposed_domains:
    # Lights & Switches
    - light
    - switch
    - input_boolean
    # Climate & Environment
    - climate
    - fan
    - humidifier
    - water_heater
    # Covers & Valves
    - cover
    - valve
    # Security
    - lock
    - alarm_control_panel
    # Media
    - media_player
    # Sensors (read-only)
    - sensor
    - binary_sensor
    # Automations
    - scene
    - script
    # Selectors
    - input_select
    - select
    # Buttons
    - button
    - input_button
    # Robots
    - vacuum
    - lawn_mower
    # Other
    - camera
    - event
EOF

    # Add service account for report_state if available
    # This uses HA's built-in JWT generation, token refresh, batching
    if [ "$has_service_account" = true ]; then
        cat >> "$package_file" << EOF
  service_account: !include ../gcp_tunnel_service_account.json
  report_state: true
EOF
        bashio::log.info "Google Assistant: report_state enabled (uses HA's batching & JWT)"
    fi

    # Add secure_devices_pin if configured
    if ! bashio::var.is_empty "$secure_pin"; then
        echo "  secure_devices_pin: \"${secure_pin}\"" >> "$package_file"
    fi

    bashio::log.info "Google Assistant: Package written to $package_file"

    # Check if this is first-time setup (packages just enabled)
    if [ -f "/config/.gcp_tunnel_needs_restart" ]; then
        rm -f "/config/.gcp_tunnel_needs_restart"
        bashio::log.info "Google Assistant: Configuration complete, restarting HA Core..."
        # Use Supervisor API to restart HA Core
        curl -s -X POST -H "Authorization: Bearer ${SUPERVISOR_TOKEN}" \
            "http://supervisor/core/restart" || true
    fi
}

# Generate or load password
get_or_generate_password() {
    if [ -f "$GENERATED_PASS_FILE" ]; then
        cat "$GENERATED_PASS_FILE"
    else
        local pass
        pass=$(head -c 24 /dev/urandom | base64 | tr -d '/+=' | head -c 32)
        echo -n "$pass" > "$GENERATED_PASS_FILE"
        chmod 600 "$GENERATED_PASS_FILE"
        echo "$pass"
    fi
}

# Show setup instructions when not configured
show_setup_instructions() {
    local auth_pass
    auth_pass=$(get_or_generate_password)

    local project_id
    project_id=$(bashio::config 'google_project_id')
    if bashio::var.is_empty "$project_id"; then
        project_id="YOUR_PROJECT_ID"
    fi

    bashio::log.info "========================================"
    bashio::log.info "        SETUP REQUIRED"
    bashio::log.info "========================================"
    bashio::log.info ""
    bashio::log.info "Run this command in your terminal:"
    bashio::log.info ""
    bashio::log.info "─────────────────────────────────────────"
    bashio::log.info "gcloud run deploy ha-tunnel \\"
    bashio::log.info "  --project=${project_id} \\"
    bashio::log.info "  --region=us-central1 \\"
    bashio::log.info "  --image=ghcr.io/bramalkema/gcp-ha-tunnel/tunnel-server:latest \\"
    bashio::log.info "  --allow-unauthenticated \\"
    bashio::log.info "  --set-env-vars=AUTH=hauser:${auth_pass} \\"
    bashio::log.info "  --timeout=3600 --min-instances=0 --max-instances=1"
    bashio::log.info "─────────────────────────────────────────"
    bashio::log.info ""
    bashio::log.info "Then copy the URL it outputs and set:"
    bashio::log.info "  server_url: <the URL>"
    bashio::log.info "  auth_pass: ${auth_pass}"
    bashio::log.info ""
    bashio::log.info "Google Home Developer Console (for Google Assistant):"
    bashio::log.info "  https://console.home.google.com"
    bashio::log.info ""
    bashio::log.info "  Fulfillment URL: <URL>/api/google_assistant"
    bashio::log.info "  Authorization URL: <URL>/auth/authorize"
    bashio::log.info "  Token URL: <URL>/auth/token"
    bashio::log.info "  Client ID: https://oauth-redirect.googleusercontent.com/r/${project_id}"
    bashio::log.info ""
    bashio::log.info "Waiting for configuration..."

    # Wait and check periodically
    while true; do
        sleep 30
        SERVER_URL=$(bashio::config 'server_url')
        if ! bashio::var.is_empty "$SERVER_URL"; then
            bashio::log.info "Configuration detected! Starting tunnel..."
            return 0
        fi
    done
}

# Sync remote UI setting to Cloud Run
sync_remote_ui_setting() {
    local remote_ui_enabled
    remote_ui_enabled=$(bashio::config 'remote_ui_enabled')

    # Default to false if not set
    if bashio::var.is_empty "$remote_ui_enabled"; then
        remote_ui_enabled="false"
    fi

    bashio::log.info "Remote UI: Setting to $remote_ui_enabled"

    # Call edge proxy endpoint to set the value
    # Uses same auth as tunnel
    local response
    response=$(curl -s -X POST \
        -u "${AUTH_USER}:${AUTH_PASS}" \
        -H "Content-Type: application/json" \
        -d "{\"enabled\": $remote_ui_enabled}" \
        "${SERVER_URL}/edge/remote-ui" 2>/dev/null || echo "error")

    if echo "$response" | grep -q "enabled"; then
        bashio::log.info "Remote UI: Synced successfully"
    else
        bashio::log.warning "Remote UI: Failed to sync setting (will retry on next connect)"
    fi
}

# Read and validate configuration
read_config() {
    SERVER_URL=$(bashio::config 'server_url')
    AUTH_USER=$(bashio::config 'auth_user')
    AUTH_PASS=$(bashio::config 'auth_pass')
    LOCAL_PORT=$(bashio::config 'local_port')
    KEEPALIVE=$(bashio::config 'keepalive')
    LOG_LEVEL=$(bashio::config 'log_level')

    # If no server_url, wait for web UI setup
    if bashio::var.is_empty "$SERVER_URL"; then
        bashio::log.info "========================================"
        bashio::log.info "    SETUP REQUIRED"
        bashio::log.info "========================================"
        bashio::log.info ""
        bashio::log.info "Open the GCP Tunnel panel in Home Assistant"
        bashio::log.info "to complete one-click setup with Google."
        bashio::log.info ""
        bashio::log.info "Waiting for setup to complete..."

        # Wait for configuration via web UI
        while bashio::var.is_empty "$SERVER_URL"; do
            sleep 10
            SERVER_URL=$(bashio::config 'server_url')
        done

        bashio::log.info "Configuration detected! Starting tunnel..."
        AUTH_PASS=$(bashio::config 'auth_pass')
    fi

    # Use generated password if none configured
    if bashio::var.is_empty "$AUTH_PASS"; then
        if [ -f "$GENERATED_PASS_FILE" ]; then
            AUTH_PASS=$(cat "$GENERATED_PASS_FILE")
            bashio::log.info "Using generated password from setup"
        else
            bashio::log.fatal "Configuration error: auth_pass is required"
            exit 1
        fi
    fi

    # Validate URL
    validate_url "$SERVER_URL"

    # Use the URL as-is - chisel handles https->wss conversion internally
    TUNNEL_URL="$SERVER_URL"

    # Set defaults
    AUTH_USER="${AUTH_USER:-hauser}"
    LOCAL_PORT="${LOCAL_PORT:-8123}"
    KEEPALIVE="${KEEPALIVE:-25s}"
    LOG_LEVEL="${LOG_LEVEL:-info}"

    # Enable debug mode if log_level is debug
    if [ "$LOG_LEVEL" = "debug" ]; then
        DEBUG_MODE=true
        log_structured "info" "config" "Debug mode enabled - structured logs at $LOG_FILE"
    fi

    log_structured "debug" "config" "server_url=$SERVER_URL"
    log_structured "debug" "config" "auth_user=$AUTH_USER"
    log_structured "debug" "config" "local_port=$LOCAL_PORT"
    log_structured "debug" "config" "keepalive=$KEEPALIVE"
}

# Build chisel command arguments
build_chisel_args() {
    CHISEL_ARGS=(
        "client"
        "--keepalive" "$KEEPALIVE"
    )

    # Add auth (mask password in logs by building args array)
    CHISEL_ARGS+=("--auth" "${AUTH_USER}:${AUTH_PASS}")

    # Set verbosity based on log level
    case "$LOG_LEVEL" in
        debug)
            CHISEL_ARGS+=("-v")
            ;;
        info|warning|error)
            # Default verbosity
            ;;
    esac

    # Add server URL
    CHISEL_ARGS+=("$TUNNEL_URL")

    # Add reverse tunnel specification
    # nginx on Cloud Run listens on :8080, proxies HTTP to :9001
    # chisel listens on :9000 for WebSocket control
    # Format: R:remote_port:local_host:local_port
    # Reverse tunnel: server listens on 9001, forwards to local nginx proxy (8888)
    CHISEL_ARGS+=("R:9001:127.0.0.1:8888")
}

# Calculate backoff with jitter
calculate_backoff() {
    # Exponential backoff
    current_backoff=$((current_backoff * BACKOFF_MULTIPLIER))

    # Cap at max
    if [ "$current_backoff" -gt "$MAX_BACKOFF" ]; then
        current_backoff=$MAX_BACKOFF
    fi

    # Add jitter (±20%)
    local jitter=$((current_backoff / 5))
    local random_jitter=$((RANDOM % (jitter * 2 + 1) - jitter))
    local backoff_with_jitter=$((current_backoff + random_jitter))

    # Ensure minimum of 1 second
    if [ "$backoff_with_jitter" -lt 1 ]; then
        backoff_with_jitter=1
    fi

    echo "$backoff_with_jitter"
}

# Reset backoff on successful connection
reset_backoff() {
    current_backoff=$INITIAL_BACKOFF
    consecutive_failures=0
}

# Start nginx proxy
# Listens on port 8888, forwards to HA Core via HTTPS
start_nginx_proxy() {
    bashio::log.info "Starting nginx proxy (8888 -> homeassistant:8123 HTTPS)..."

    # Create required temp directories
    mkdir -p /tmp/nginx-client-body /tmp/nginx-proxy /tmp/nginx-fastcgi /tmp/nginx-uwsgi /tmp/nginx-scgi /run/nginx

    # Stop any existing nginx
    nginx -s stop 2>/dev/null || pkill nginx 2>/dev/null || true
    sleep 1

    # Test nginx config first
    bashio::log.info "Testing nginx configuration..."
    if ! nginx -t 2>&1; then
        bashio::log.error "nginx config test failed"
        return 1
    fi

    # Start nginx (keep in foreground for better process management)
    bashio::log.info "Starting nginx..."
    nginx -g 'daemon off;' &
    local nginx_pid=$!

    sleep 2

    # Verify it's running
    if ! kill -0 "$nginx_pid" 2>/dev/null; then
        bashio::log.error "nginx not running after start (pid: $nginx_pid)"
        return 1
    fi

    bashio::log.info "nginx started successfully (pid: $nginx_pid)"
}

# Analyze error and show helpful message
analyze_error() {
    local log_file="$1"
    local exit_code="$2"

    # Read last few lines of log
    local log_tail=""
    if [ -f "$log_file" ]; then
        log_tail=$(tail -20 "$log_file" 2>/dev/null || true)
    fi

    # Detect common errors and show actionable messages
    if echo "$log_tail" | grep -qi "401\|unauthorized\|authentication"; then
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "AUTH ERROR: Wrong username or password"
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "Fix: Check auth_user and auth_pass match Cloud Run"
        bashio::log.error "     Run ./scripts/rotate-password.sh to reset"
    elif echo "$log_tail" | grep -qi "no such host\|could not resolve\|dns"; then
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "DNS ERROR: Cannot resolve server URL"
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "Fix: Check server_url is correct"
        bashio::log.error "     Verify Cloud Run service is deployed"
    elif echo "$log_tail" | grep -qi "connection refused\|connect:"; then
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "CONNECTION ERROR: Server not reachable"
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "Fix: Check internet connection"
        bashio::log.error "     Verify Cloud Run service is running"
    elif echo "$log_tail" | grep -qi "certificate\|tls\|ssl"; then
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "SSL ERROR: Certificate problem"
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "Fix: Ensure server_url starts with https://"
    elif echo "$log_tail" | grep -qi "timeout\|deadline"; then
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "TIMEOUT: Connection timed out"
        bashio::log.error "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        bashio::log.error "This is normal after 60 min (Cloud Run limit)"
        bashio::log.error "Auto-reconnecting..."
    elif [ "$exit_code" -eq 0 ]; then
        bashio::log.info "Tunnel closed cleanly"
    else
        bashio::log.warning "Tunnel exited (code: $exit_code)"
    fi
}

# Run chisel and monitor
run_tunnel() {
    local log_file="/tmp/chisel.log"

    bashio::log.info "Starting chisel client..."

    # Log connection details (without password)
    bashio::log.info "Server: $TUNNEL_URL"
    bashio::log.info "User: $AUTH_USER"
    bashio::log.info "Local port: $LOCAL_PORT"
    bashio::log.info "Keepalive: $KEEPALIVE"
    bashio::log.info "Tunnel: R:9001:127.0.0.1:8888 -> homeassistant:8123 (HTTPS via nginx)"

    # Start chisel, capture output for error analysis
    /usr/local/bin/chisel "${CHISEL_ARGS[@]}" 2>&1 | tee "$log_file" &
    chisel_pid=$!

    bashio::log.info "Chisel started with PID: $chisel_pid"

    # Wait for process
    wait "$chisel_pid"
    local exit_code=$?

    # Analyze what went wrong
    analyze_error "$log_file" "$exit_code"

    chisel_pid=""
    return $exit_code
}

# Start the setup web UI
start_webapp() {
    bashio::log.info "Starting setup web UI on port 8099..."
    cd /webapp
    python3 app.py &
    webapp_pid=$!
    bashio::log.info "Web UI started (pid: $webapp_pid)"
}

# Main loop
main() {
    bashio::log.info "========================================"
    bashio::log.info "GCP Tunnel Client starting"
    bashio::log.info "========================================"

    # Always start the web UI for setup/status
    start_webapp

    # Verify chisel binary
    if ! command -v /usr/local/bin/chisel &>/dev/null; then
        bashio::log.fatal "Chisel binary not found at /usr/local/bin/chisel"
        exit 1
    fi

    local chisel_version
    chisel_version=$(/usr/local/bin/chisel --version 2>&1 || echo "unknown")
    bashio::log.info "Chisel version: $chisel_version"

    # Read configuration
    read_config
    build_chisel_args

    # Setup Google Assistant package if configured
    setup_google_assistant

    # Start nginx proxy (converts HTTP to HTTPS for HA Core)
    if ! start_nginx_proxy; then
        bashio::log.fatal "Failed to start nginx proxy"
        exit 1
    fi

    # Sync remote UI setting to Cloud Run
    sync_remote_ui_setting

    # Main reconnect loop
    while true; do
        # Rotate log if needed
        rotate_log

        log_structured "info" "tunnel" "Connecting to $TUNNEL_URL"
        bashio::log.info "Connecting to tunnel..."

        # Track connection start time
        local start_time
        start_time=$(date +%s)

        # Run tunnel (blocks until disconnect)
        if run_tunnel; then
            # Clean exit (shouldn't happen normally)
            log_structured "warning" "tunnel" "Clean exit"
            bashio::log.warning "Tunnel exited cleanly"
        else
            local exit_code=$?
            log_structured "warning" "tunnel" "Disconnected with exit_code=$exit_code"
            bashio::log.warning "Tunnel disconnected (exit code: $exit_code)"
        fi

        # Calculate connection duration
        local end_time
        end_time=$(date +%s)
        local duration=$((end_time - start_time))

        # If connection lasted more than 60 seconds, reset backoff
        if [ "$duration" -gt 60 ]; then
            log_structured "info" "tunnel" "Stable connection for ${duration}s, resetting backoff"
            bashio::log.info "Connection was stable for ${duration}s, resetting backoff"
            reset_backoff
        else
            ((consecutive_failures++))
            log_structured "warning" "tunnel" "Quick disconnect after ${duration}s, failure #${consecutive_failures}"
            bashio::log.warning "Quick disconnect (${duration}s), failure #${consecutive_failures}"
        fi

        # Calculate wait time
        local wait_time
        wait_time=$(calculate_backoff)

        log_structured "info" "tunnel" "Reconnecting in ${wait_time}s (backoff=${current_backoff})"
        bashio::log.info "Reconnecting in ${wait_time}s..."

        # Interruptible sleep
        local waited=0
        while [ "$waited" -lt "$wait_time" ]; do
            sleep 1
            ((waited++))
        done
    done
}

# Run main
main "$@"
