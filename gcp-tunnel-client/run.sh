#!/usr/bin/with-contenv bashio
#
# GCP Tunnel Client - connects to Cloud Run chisel server
#
# Features:
# - Exponential backoff on reconnect
# - Graceful shutdown handling
# - Connection monitoring
#

# Exit on undefined variables
set -u

# Configuration
MAX_BACKOFF=300  # 5 minutes max
INITIAL_BACKOFF=5
BACKOFF_MULTIPLIER=2

# State
current_backoff=$INITIAL_BACKOFF
consecutive_failures=0
chisel_pid=""

# Graceful shutdown handler
shutdown() {
    bashio::log.info "Received shutdown signal, stopping tunnel..."
    if [ -n "$chisel_pid" ] && kill -0 "$chisel_pid" 2>/dev/null; then
        kill -TERM "$chisel_pid" 2>/dev/null || true
        wait "$chisel_pid" 2>/dev/null || true
    fi
    # Also stop socat proxy
    pkill -f "socat.*TCP-LISTEN:8888" 2>/dev/null || true
    bashio::log.info "Tunnel stopped"
    exit 0
}

# Set up signal handlers
trap shutdown SIGTERM SIGINT SIGHUP

# Validate URL format
validate_url() {
    local url="$1"
    if [[ ! "$url" =~ ^https?:// ]] && [[ ! "$url" =~ ^wss?:// ]]; then
        bashio::log.fatal "Invalid server URL format: $url"
        bashio::log.fatal "URL must start with https:// or wss://"
        exit 1
    fi
}

# Mark that we need a restart after first config
mark_restart_needed() {
    touch "/config/.gcp_tunnel_needs_restart"
}

# Ensure packages are enabled in configuration.yaml
enable_packages() {
    local config_file="/config/configuration.yaml"

    # Check if packages line already exists
    if grep -q "packages:" "$config_file" 2>/dev/null; then
        bashio::log.info "Packages already configured in configuration.yaml"
        return 0
    fi

    bashio::log.info "Adding packages configuration to configuration.yaml..."

    # Check if homeassistant: section exists
    if grep -q "^homeassistant:" "$config_file" 2>/dev/null; then
        # Add packages under existing homeassistant section
        sed -i '/^homeassistant:/a\  packages: !include_dir_named packages' "$config_file"
    else
        # Add new homeassistant section at the top
        sed -i '1i\homeassistant:\n  packages: !include_dir_named packages\n' "$config_file"
    fi

    bashio::log.info "Packages enabled - HA Core will restart automatically"
    mark_restart_needed
}

# Setup Google Assistant package configuration
setup_google_assistant() {
    local project_id
    project_id=$(bashio::config 'google_project_id')

    # Skip if no project ID configured
    if bashio::var.is_empty "$project_id"; then
        bashio::log.info "Google Assistant: No project_id configured, skipping auto-setup"
        return 0
    fi

    bashio::log.info "Google Assistant: Setting up packages configuration..."

    # Create packages directory if it doesn't exist
    mkdir -p /config/packages

    # Enable packages in configuration.yaml
    enable_packages

    # Get optional PIN for secure devices
    local secure_pin
    secure_pin=$(bashio::config 'google_secure_devices_pin')

    # Write the google_assistant package
    local package_file="/config/packages/gcp_tunnel_google_assistant.yaml"

    cat > "$package_file" << EOF
# Auto-generated by GCP Tunnel Client add-on
# Do not edit manually - changes will be overwritten

google_assistant:
  project_id: ${project_id}
  report_state: true
  expose_by_default: true
  exposed_domains:
    - switch
    - light
    - climate
    - cover
    - fan
    - lock
    - media_player
    - scene
    - script
    - sensor
    - vacuum
EOF

    # Add secure_devices_pin if configured
    if ! bashio::var.is_empty "$secure_pin"; then
        echo "  secure_devices_pin: \"${secure_pin}\"" >> "$package_file"
    fi

    bashio::log.info "Google Assistant: Package written to $package_file"

    # Check if this is first-time setup (packages just enabled)
    if [ -f "/config/.gcp_tunnel_needs_restart" ]; then
        rm -f "/config/.gcp_tunnel_needs_restart"
        bashio::log.info "Google Assistant: Configuration complete, restarting HA Core..."
        # Use Supervisor API to restart HA Core
        curl -s -X POST -H "Authorization: Bearer ${SUPERVISOR_TOKEN}" \
            "http://supervisor/core/restart" || true
    fi
}

# Read and validate configuration
read_config() {
    SERVER_URL=$(bashio::config 'server_url')
    AUTH_USER=$(bashio::config 'auth_user')
    AUTH_PASS=$(bashio::config 'auth_pass')
    LOCAL_PORT=$(bashio::config 'local_port')
    KEEPALIVE=$(bashio::config 'keepalive')
    LOG_LEVEL=$(bashio::config 'log_level')

    # Validate required config
    if bashio::var.is_empty "$SERVER_URL"; then
        bashio::log.fatal "Configuration error: server_url is required"
        exit 1
    fi

    if bashio::var.is_empty "$AUTH_PASS"; then
        bashio::log.fatal "Configuration error: auth_pass is required"
        exit 1
    fi

    # Validate URL
    validate_url "$SERVER_URL"

    # Use the URL as-is - chisel handles https->wss conversion internally
    TUNNEL_URL="$SERVER_URL"

    # Set defaults
    AUTH_USER="${AUTH_USER:-hauser}"
    LOCAL_PORT="${LOCAL_PORT:-8123}"
    KEEPALIVE="${KEEPALIVE:-25s}"
    LOG_LEVEL="${LOG_LEVEL:-info}"
}

# Build chisel command arguments
build_chisel_args() {
    CHISEL_ARGS=(
        "client"
        "--keepalive" "$KEEPALIVE"
    )

    # Add auth (mask password in logs by building args array)
    CHISEL_ARGS+=("--auth" "${AUTH_USER}:${AUTH_PASS}")

    # Set verbosity based on log level
    case "$LOG_LEVEL" in
        debug)
            CHISEL_ARGS+=("-v")
            ;;
        info|warning|error)
            # Default verbosity
            ;;
    esac

    # Add server URL
    CHISEL_ARGS+=("$TUNNEL_URL")

    # Add reverse tunnel specification
    # nginx on Cloud Run listens on :8080, proxies HTTP to :9001
    # chisel listens on :9000 for WebSocket control
    # Format: R:remote_port:local_host:local_port
    # Reverse tunnel: server listens on 9001, forwards to local socat proxy (8888)
    CHISEL_ARGS+=("R:9001:127.0.0.1:8888")
}

# Calculate backoff with jitter
calculate_backoff() {
    # Exponential backoff
    current_backoff=$((current_backoff * BACKOFF_MULTIPLIER))

    # Cap at max
    if [ "$current_backoff" -gt "$MAX_BACKOFF" ]; then
        current_backoff=$MAX_BACKOFF
    fi

    # Add jitter (Â±20%)
    local jitter=$((current_backoff / 5))
    local random_jitter=$((RANDOM % (jitter * 2 + 1) - jitter))
    local backoff_with_jitter=$((current_backoff + random_jitter))

    # Ensure minimum of 1 second
    if [ "$backoff_with_jitter" -lt 1 ]; then
        backoff_with_jitter=1
    fi

    echo "$backoff_with_jitter"
}

# Reset backoff on successful connection
reset_backoff() {
    current_backoff=$INITIAL_BACKOFF
    consecutive_failures=0
}

# Start socat proxy
# Listens on port 8888, forwards to HA Core via Supervisor internal proxy
start_socat_proxy() {
    bashio::log.info "Starting socat proxy (8888 -> supervisor:80 -> HA Core)..."

    # Kill any existing socat
    pkill -f "socat.*TCP-LISTEN:8888" 2>/dev/null || true

    # Start socat in background
    # TCP-LISTEN: accept plain HTTP on 8888
    # OPENSSL: connect to HA with SSL
    # openssl-commonname= to set SNI header correctly
    socat TCP-LISTEN:8888,fork,reuseaddr OPENSSL:homeassistant:8123,verify=0,openssl-commonname=homeassistant &
    socat_pid=$!

    bashio::log.info "socat started with PID: $socat_pid"
    sleep 1

    # Verify it's running
    if ! kill -0 "$socat_pid" 2>/dev/null; then
        bashio::log.error "socat failed to start"
        return 1
    fi
}

# Run chisel and monitor
run_tunnel() {
    bashio::log.info "Starting chisel client..."

    # Log connection details (without password)
    bashio::log.info "Server: $TUNNEL_URL"
    bashio::log.info "User: $AUTH_USER"
    bashio::log.info "Local port: $LOCAL_PORT"
    bashio::log.info "Keepalive: $KEEPALIVE"
    bashio::log.info "Tunnel: R:9001:127.0.0.1:8888 -> homeassistant:8123 (HTTPS via socat)"

    # Start chisel in background
    /usr/local/bin/chisel "${CHISEL_ARGS[@]}" &
    chisel_pid=$!

    bashio::log.info "Chisel started with PID: $chisel_pid"

    # Wait for process
    wait "$chisel_pid"
    local exit_code=$?

    chisel_pid=""
    return $exit_code
}

# Main loop
main() {
    bashio::log.info "========================================"
    bashio::log.info "GCP Tunnel Client starting"
    bashio::log.info "========================================"

    # Verify chisel binary
    if ! command -v /usr/local/bin/chisel &>/dev/null; then
        bashio::log.fatal "Chisel binary not found at /usr/local/bin/chisel"
        exit 1
    fi

    local chisel_version
    chisel_version=$(/usr/local/bin/chisel --version 2>&1 || echo "unknown")
    bashio::log.info "Chisel version: $chisel_version"

    # Read configuration
    read_config
    build_chisel_args

    # Setup Google Assistant package if configured
    setup_google_assistant

    # Start socat SSL proxy (converts HTTP to HTTPS for HA Core)
    if ! start_socat_proxy; then
        bashio::log.fatal "Failed to start socat SSL proxy"
        exit 1
    fi

    # Main reconnect loop
    while true; do
        bashio::log.info "Connecting to tunnel..."

        # Track connection start time
        local start_time
        start_time=$(date +%s)

        # Run tunnel (blocks until disconnect)
        if run_tunnel; then
            # Clean exit (shouldn't happen normally)
            bashio::log.warning "Tunnel exited cleanly"
        else
            local exit_code=$?
            bashio::log.warning "Tunnel disconnected (exit code: $exit_code)"
        fi

        # Calculate connection duration
        local end_time
        end_time=$(date +%s)
        local duration=$((end_time - start_time))

        # If connection lasted more than 60 seconds, reset backoff
        if [ "$duration" -gt 60 ]; then
            bashio::log.info "Connection was stable for ${duration}s, resetting backoff"
            reset_backoff
        else
            ((consecutive_failures++))
            bashio::log.warning "Quick disconnect (${duration}s), failure #${consecutive_failures}"
        fi

        # Calculate wait time
        local wait_time
        wait_time=$(calculate_backoff)

        bashio::log.info "Reconnecting in ${wait_time}s..."

        # Interruptible sleep
        local waited=0
        while [ "$waited" -lt "$wait_time" ]; do
            sleep 1
            ((waited++))
        done
    done
}

# Run main
main "$@"
